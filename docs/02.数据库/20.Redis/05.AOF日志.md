---
title: AOF日志
date: 2022-06-10 15:47:50
permalink: /pages/da7318/
categories:
  - 数据库
  - Redis
tags:
  - 
---

**Redis 数据都在内存里，一旦宕机，数据将全部丢失，如何做到避免数据丢失呢？**

直接从后端数据库恢复可不可行，这种方式存在两个问题：

1. 要频繁访问数据库，会给数据库带来巨大的压力；
2. 从数据库读取，肯定不从Redis读取慢，导致应用程序响应变慢。

所以，实现Redis的持久化，避免直接从数据库恢复，至关重要。

Redis 的持久化主要有两大机制，即 **AOF 日志**和 **RDB 快照**，本文学习AOF 日志

## AOF日志如何实现？

AOF日志里记录的是什么？

AOF日志里记录是Redis收到的每一条写命令，并以文本方式保存

> 和Mysql的redo日志比较，Mysql的redo日志记录的是修改后的数据

Redis 采用先执行命令操作，再写日志的写后方式

> 比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），比如 redo log（重做日志）就是先写日志再操作

采用写后日志方式的优势：

- 避免记录错误命令的情况，如果命令是错的，执行操作步骤就直接向客户端报错了
- 不会阻塞当前的写操作

不过也有潜在的风险：

- 执行完命令还没来得及写日志就宕机了，会有数据丢失风险
- AOF 日志也是在主线程中执行的，会给下一个操作带来阻塞风险

这两个风险都与AOF日志的写回磁盘时机有关，如果能控制一个命令执行完后AOF日志的写盘时机，风险就可以控制了，Redis 里提供了三种回写策略。

## 三种回写策略

对应配置文件的appendfsync三个可选值：

- **Always**，同步回写：每个写命令执行完立马同步将日志写入磁盘
- **Everysec**，每秒写：每个写命令执行完，先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘
- **No**，由操作系统控制回写：由操作同控制AOF文件内存缓存区的写盘时机

三种方式比较：

<img src="http://img.zhoubg.cn/static/image-20220610162408867.png" alt="image-20220610162408867" style="zoom:67%;" />

三种回写策略的选择，要高性能就选No策略，要可靠性保证就选Always策略，均衡一点就选Everysec策略。

## AOF日志重写

随着接收的命令越来越多，AOF日志文件会越来越大，也会带来性能为题：

- 系统文件本身对文件大小有限制，无法保存过大文件
- 文件过大，追加命令效率也会变低
- 文件过大，故障恢复时AOF日志的命令重新执行过程缓慢

要采取一定的控制手段避免文件过大，这就是AOF日志重写的作用了

AOF日志重写就是基于Redis的当前状态创建一个新的AOF文件，读取所有的键值，每个键值用一条命令写入新的AOF文件。重写机制有“多变一”的功能，把日志中的多条命令变成一条，这样日志文件也变小了

## AOF 重写会阻塞吗？

AOF重写是有后台线程 bgrewriteaof 完成的，不会阻塞主线程。

AOF重写过程可以总结为“**一个拷贝，两个日志**”

- 一个拷贝：主线程fork出后台bgrewriteaof子线程，并把主线程内存拷贝一份给子线程，里面有最新的数据库

- 两个日志：AOF 日志 和 AOF 重写日志。

  子线程不会阻塞主线程，那么主线程可以在重写过程中继续处理新操作，操作将记录到AOF日志缓冲区

  子线程也不能丢失重写过程中产生的新操作，会把新操作也记录一份到AOF重写日志缓冲区，待重写完成后写入新的AOF文件并替换旧的AOF文件

![image-20220616113324263](http://img.zhoubg.cn/static/image-20220616113324263.png)



## 总结

Redis 使用记录AOF日志的方法避免数据丢失。该方法通过逐一记录写操作的命令，并在恢复时重新逐一执行命令，来保证数据的可靠性。

Redis 考虑到了性能的影响，提供了三种AOF日志回写方式：Always、Everysec、No，三种方式可靠性从高到低，性能从低到高。

Redis 为了避免AOF日志文件过大，提供了AOF重写机制。以数据库最新的状态，生成插入命令，作为新日志。重写通过后台线程完成，避免了阻塞。