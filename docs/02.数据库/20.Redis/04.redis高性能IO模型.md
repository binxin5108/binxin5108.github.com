---
title: redis高性能IO模型
date: 2022-06-09 11:01:29
permalink: /pages/3cdfcb/
categories:
  - 数据库
  - Redis
tags:
  - 
---

### Redis 真的是单线程吗？

我们通常说，Redis 是单线程，**主要是指 Redis 的网络 IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程**。

Redis的其他功能，比如持久化、异步删除、集群数据同步等操作，是有额外的线程执行。



## 为什么使用单线程？

先看一下多线的的开销

### 多线程的开销

期望：使用多线程，可以增加系统吞吐率，但是前提是拥有合理资源分配和良好的系统设计

实际：刚开始增加线程时，吞吐率会增加，但是进一步增加线程，吞吐率增长迟缓，有事甚至下降

<img src="http://img.zhoubg.cn/static/image-20220609145442851.png" alt="image-20220609145442851" style="zoom:67%;" />

**多线程编程模式面临的共享资源的并发访问控制问题**，而且采用多线程一般会引入同步原语保护共享资源的并发访问，这会降低系统的易调试性和可维护性。为了避免这些问题，Redis直接采用单线程。



### 单线程为什么快？

Redis高性能的原因，一方面是全部内存操作，加上高效的数据结构。

另一方面就是 Redis 采用了**多路复用机制**，要了解多路复用，先要明白网络的基本 IO 模型和潜在的阻塞点，Redis单线程如果在阻塞点上阻塞了那肯定快不了



#### 网络基本IO模型与阻塞点

以 Redis  的 GET 请求为例，Redis 服务端首先要监听客户端请求（bind/listen），然后建立连接（accept），从socket 中读取数据（recv），解析客户端请求数据（parse），根据请求类型读取键值对数据（get），最后给客户端返回结果，即想socket 总写会数据（send）。

其中，bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作。

<img src="http://img.zhoubg.cn/static/image-20220609153701053.png" alt="image-20220609153701053" style="zoom:67%;" />

其中有两个潜在的阻塞点：**accept()** 操作 和 **recv()** 操作。

- Redis 监听到一个客户端连接，如果连接一直未能建立成功是，accept会阻塞，此时其他客户端不能与Redis连接
- Redis 通过 recv 从一个客户端读取数据，如果数据一直没到达，Redis 也会阻塞在 recv

这就导致了Redis整个线程的阻塞，无法处理其他客户端请求，效率低下。但是 socket 网络模型本身支持非阻塞模式。

#### 非阻塞模式

Socket 网络模型的非阻塞设置，主要体现在三个系统函数调用上：

<img src="http://img.zhoubg.cn/static/image-20220609161148535.png" alt="image-20220609161148535" style="zoom:67%;" />

- 调用listen() 方法设置非阻塞模式，accept() 操作就不会阻塞，没有连接到来，Redis线程可以干其他事
- 调用accept() 方法设置非阻塞模式，send()/recv() 查找就不会阻塞，已连接套接字上数据没有到达，Redis线程可以干其他事

上述两种设置非阻塞后，Redis线程可以不用等待，但总的有一种机制保证当请求来了或者数据到达能通知Redis线程去处理吧，这就是linux中 IO 多路复用机制的作用了



#### 基于多路复用的高可用IO模型

Linux 中 IO 多路复用机制是指一个线程处理多个 IO 流，就是常说的 select/epoll 机制。

Redis 运行单线程情况下，**该机制允许在内核中，同时监听多有监听套接字和已连接套接字**。监听这些套接字上连接请求和数据请求，一旦请求到达，就交个Redis线程处理。

下图就是Redis了IO 多路复用模型，内核调用epoll机制监听多个套接字FD，此时Redis不会阻塞在某个特定监听或已连接套接字上，也就是不会阻塞在某个特定的请求处理上，可以同时和多个客户端连接并处理请求，提升并发性。

<img src="http://img.zhoubg.cn/static/image-20220609162735718.png" alt="image-20220609162735718" style="zoom:67%;" />

为了请求到达时通知Redis，select/epoll 提供了**基于事件的回调机制，即针对不同的事件，调用不同的处理函数**

如图所示，当监测的FD上一旦有请求到达，就会触发相应的事件（AcceptEvent、ReadEvent、WriteEvent），这些事件会先进入到一个事件队列中，Redis单线程会不断的对该事件队列进行处理，针对不同的事件类型调用不同的处理函数，这样就避免了Redis线程一直轮询浪费CPU资源。

不同的操作系统，多路不用有不同的实现，既有基于 Linux 系统下的 select 和 epoll 实现，也有基于 FreeBSD 的 kqueue 实现，以及基于 Solaris 的 evport 实现，这样，可以根据Redis 实际运行的操作系统，选择相应的多路复用实现。

## 总结

redis真的是单线程吗？

>  Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线

为什么用单线程？

> 采用单线程的一个核心原因是避免多线程开发的并发控制问题

单线程为什么这么快？

> 单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点