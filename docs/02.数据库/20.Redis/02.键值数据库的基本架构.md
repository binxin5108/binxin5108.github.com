---
title: 一个键值对数据库的基本架构
date: 2022-06-06 16:21:15
permalink: /pages/166b3b/
categories:
  - 数据库
  - Redis
tags:
  - 
---

假设我们自己要构造一个简单的键值数据库，暂且叫它 SimpleKV，开始构造时我们要思考以下问题：

- 可以存什么样的数据？-- **数据模型**
- 对数据可以做什么操作？-- **操作接口**
- 数据存在内存还是外存？

理解数据模型和操作接口，就能知道键值数据库哪些场景下适合使用，哪些不适合

那么，对于 Redis 来说，它到底能做什么，不能做什么呢？只有先搞懂它的数据模型和操作接口，我们才能真正把“这块好钢用在刀刃上”。

## 数据模型-可以存哪些数据？

对于键值数据库，基本数据模型是 `key-value`模型

`key` 的类型不同键值数据库差异不大，一般都为 `String` 类型，而 `value` 类型差异较大，在对键值数据库选型时，一个重要的考虑因数是**它支持的 `value` 类型**

我们设计 SimpleKV 毕竟只是个简单的键值数据库，key 设计String类型，value设计为基本数据类型即可，例如String，整型等。 但在实际生产中的键值数据库，value 类型可以是复杂类型。

Redis 的 `value` 类型包括了 String 、哈希表、列表、集合、有序集合等。

**Redis 能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的 value**



## 操作接口-可以对数据做什么操作？

对于 SimpleKV 这个简单的键值数据库，操作无外乎就是增删查改。

- PUT：新写或更新入一个key-value对（有些键值数据库叫做SET）
- GET：根据key获取对应的value值
- DELETE：根据key删除整个key-value对

其他情况：

- SCAN：即根据一段 key 的范围返回相应的 value值。

因此**PUT/GET/DELETE/SCAN 是一个键值数据库的基本操作集合**。

实例业务场景中还有更多的操作，例如判断某个Key是否存在，可以定义一个EXISTS 接口。

对于多样化的 value 类型时，还需要相应 value 类型的操作，例如 Redis 的value有列表类型，因此它的接口就包括对列表value的操作。



## 键值对保存在内存还是外存？

内存：读写快，百 ns  级，一旦掉电，所有数据丢失

外存：避免数据丢失，受限于磁盘的满速读写，几ms级，键值数据库整体性能拉低

因此，**如何进行设计选择，我们通常需要考虑键值数据库的主要应用场景**。

缓存场景下数据需要快速访问但允许丢失，对Redis 而言 ，缓存是重要的一个应用场景。

为了和 Redis 保持一致，我们的 SimpleKV 就采用内存保存键值数据。



大体来说，一个键值数据库包括了**访问框架、索引模块、操作模块和存储模块**四部分（见下图）。

<img src="http://img.zhoubg.cn/static/image-20220607163411394.png" alt="image-20220607163411394" style="zoom:50%;" />

## 访问模式选择

访问模式通常有两种：

1. **通过函数库调用的方式供外部应用使用**

   上图的libsimplekv.so，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能，例子：RocksDB

2. **是通过网络框架以 Socket 通信的形式对外提供键值对操作**

   网络框架中包括 Socket Server 和协议解析。可以提供更广泛的受用面。例子：Redis、Memcached

   潜在的设计问题：网络连接、请求解析、数据存取处理使用单线程还是多线程？单线程会有阻塞问题，多线程会有线程竞争问题 -->>**IO模型的设计** 

   如何做到“单线程、高性能”-->> **多路复用**



## 索引-如何定位键值对的位置

SimpleKV 解析了客户端发来的请求后，知道了要操作对应的键值对，此时 SimpleKV 需要先找到对应的键值对。

**索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作。**

常用的索引类型有哈希表、B+树、字典树等。

一般内存键值数据库（例如 Redis）采用哈希表作为索引，很大一部分原因在于，其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表O(1) 的操作复杂度相匹配。

SimpleKV 的索引根据Key 找到 value 的存储位置即可，但是对于Redis 而言，value支持多种类型，通过索引找到了value的位置访问后，仍然需要**从value 的复杂结构（例如集合和列表）中进一步找到实际需要的数据，这个操作依赖与它们本身的数据结构**

Redis 采用一些常见的高效索引结构作为某些value结构的底层数据结构，这一技术路线为Redis实现高性能访问提供了良好的支撑。



## 不同操作的具体逻辑是怎样的？

索引模块根据key找到value的位置后，需要进一步执行操作：

- GET/SCAN：根据 value 的位置返回 value 的值即可
- PUT：为新键值对分配内存空间
- DELETE：删除键值对，释放内存空间

PUT 和 DELETE 两种操作涉及分配和释放内存，这就涉及存储模块了，需要一个内存分配器

对于 SimpleKVM 可以采用常用的内存分配器 glibc 的 malloc 和 free，这样可以不用特别考虑内存空间管理问题。，glibc 的分配器在处理随机的大小内存块分配时会产生，会有内存碎片问题



## 持久化-如何实现重启后快速提供服务？

SimpleKV 依赖内存保存数据，提供快速访问，但是如果要重启后能快速重新提供服务，需要提供持久化功能。

可以直接采用保存到磁盘文件中，保存时机的选择

1. 对于每一个键值对操作，SimpleKV 都对其进行落盘保存，性能会受影响
2. 周期性保存到文件中，避免性能影响，有丢失数据风险

同样的，Redis 也有持久化功能，不过，为了适应不同的业务场景，Redis为持久化提供了诸多的执行机制和优化改进



## 总结

下图是我们自己设计的SimpleKV 数据库到 Redis的架构对比图：可以看到组件基本类似

Redis 对这些组件或者功能进行了扩展，或者说是进行了精细优化，从而满足了功能和性能等方面的要求。

![image-20220607173959783](http://img.zhoubg.cn/static/image-20220607173959783.png)



- Redis 通过网络框架访问，不在是动态库，扩大了Redis的应用范围
- Redis 中的 value 类型丰富，也带来了更多的操作接口，比如列表的LPUSH/LPOP，接口的SADD/SREM
- Redis 持久化支持两种方式：日志（AOF）和快照（RDB）
- Redis 有集群支撑模块，支持高可靠和高可扩展

## 和Redis相比，SimpleKV 还缺少什么

<img src="http://img.zhoubg.cn/static/image-20220608160516875.png" alt="image-20220608160516875" style="zoom:80%;" />