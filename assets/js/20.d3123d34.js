(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{512:function(v,_,t){"use strict";t.r(_);var s=t(22),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("strong",[v._v("Redis 数据都在内存里，一旦宕机，数据将全部丢失，如何做到避免数据丢失呢？")])]),v._v(" "),t("p",[v._v("直接从后端数据库恢复可不可行，这种方式存在两个问题：")]),v._v(" "),t("ol",[t("li",[v._v("要频繁访问数据库，会给数据库带来巨大的压力；")]),v._v(" "),t("li",[v._v("从数据库读取，肯定不从Redis读取慢，导致应用程序响应变慢。")])]),v._v(" "),t("p",[v._v("所以，实现Redis的持久化，避免直接从数据库恢复，至关重要。")]),v._v(" "),t("p",[v._v("Redis 的持久化主要有两大机制，即 "),t("strong",[v._v("AOF 日志")]),v._v("和 "),t("strong",[v._v("RDB 快照")]),v._v("，本文学习AOF 日志")]),v._v(" "),t("h2",{attrs:{id:"aof日志如何实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof日志如何实现"}},[v._v("#")]),v._v(" AOF日志如何实现？")]),v._v(" "),t("p",[v._v("AOF日志里记录的是什么？")]),v._v(" "),t("p",[v._v("AOF日志里记录是Redis收到的每一条写命令，并以文本方式保存")]),v._v(" "),t("blockquote",[t("p",[v._v("和Mysql的redo日志比较，Mysql的redo日志记录的是修改后的数据")])]),v._v(" "),t("p",[v._v("Redis 采用先执行命令操作，再写日志的写后方式")]),v._v(" "),t("blockquote",[t("p",[v._v("比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），比如 redo log（重做日志）就是先写日志再操作")])]),v._v(" "),t("p",[v._v("采用写后日志方式的优势：")]),v._v(" "),t("ul",[t("li",[v._v("避免记录错误命令的情况，如果命令是错的，执行操作步骤就直接向客户端报错了")]),v._v(" "),t("li",[v._v("不会阻塞当前的写操作")])]),v._v(" "),t("p",[v._v("不过也有潜在的风险：")]),v._v(" "),t("ul",[t("li",[v._v("执行完命令还没来得及写日志就宕机了，会有数据丢失风险")]),v._v(" "),t("li",[v._v("AOF 日志也是在主线程中执行的，会给下一个操作带来阻塞风险")])]),v._v(" "),t("p",[v._v("这两个风险都与AOF日志的写回磁盘时机有关，如果能控制一个命令执行完后AOF日志的写盘时机，风险就可以控制了，Redis 里提供了三种回写策略。")]),v._v(" "),t("h2",{attrs:{id:"三种回写策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三种回写策略"}},[v._v("#")]),v._v(" 三种回写策略")]),v._v(" "),t("p",[v._v("对应配置文件的appendfsync三个可选值：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Always")]),v._v("，同步回写：每个写命令执行完立马同步将日志写入磁盘")]),v._v(" "),t("li",[t("strong",[v._v("Everysec")]),v._v("，每秒写：每个写命令执行完，先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘")]),v._v(" "),t("li",[t("strong",[v._v("No")]),v._v("，由操作系统控制回写：由操作同控制AOF文件内存缓存区的写盘时机")])]),v._v(" "),t("p",[v._v("三种方式比较：")]),v._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"http://img.zhoubg.cn/static/image-20220610162408867.png",alt:"image-20220610162408867"}}),v._v(" "),t("p",[v._v("三种回写策略的选择，要高性能就选No策略，要可靠性保证就选Always策略，均衡一点就选Everysec策略。")]),v._v(" "),t("h2",{attrs:{id:"aof日志重写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof日志重写"}},[v._v("#")]),v._v(" AOF日志重写")]),v._v(" "),t("p",[v._v("随着接收的命令越来越多，AOF日志文件会越来越大，也会带来性能为题：")]),v._v(" "),t("ul",[t("li",[v._v("系统文件本身对文件大小有限制，无法保存过大文件")]),v._v(" "),t("li",[v._v("文件过大，追加命令效率也会变低")]),v._v(" "),t("li",[v._v("文件过大，故障恢复时AOF日志的命令重新执行过程缓慢")])]),v._v(" "),t("p",[v._v("要采取一定的控制手段避免文件过大，这就是AOF日志重写的作用了")]),v._v(" "),t("p",[v._v("AOF日志重写就是基于Redis的当前状态创建一个新的AOF文件，读取所有的键值，每个键值用一条命令写入新的AOF文件。重写机制有“多变一”的功能，把日志中的多条命令变成一条，这样日志文件也变小了")]),v._v(" "),t("h2",{attrs:{id:"aof-重写会阻塞吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写会阻塞吗"}},[v._v("#")]),v._v(" AOF 重写会阻塞吗？")]),v._v(" "),t("p",[v._v("AOF重写是有后台线程 bgrewriteaof 完成的，不会阻塞主线程。")]),v._v(" "),t("p",[v._v("AOF重写过程可以总结为“"),t("strong",[v._v("一个拷贝，两个日志")]),v._v("”")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("一个拷贝：主线程fork出后台bgrewriteaof子线程，并把主线程内存拷贝一份给子线程，里面有最新的数据库")])]),v._v(" "),t("li",[t("p",[v._v("两个日志：AOF 日志 和 AOF 重写日志。")]),v._v(" "),t("p",[v._v("子线程不会阻塞主线程，那么主线程可以在重写过程中继续处理新操作，操作将记录到AOF日志缓冲区")]),v._v(" "),t("p",[v._v("子线程也不能丢失重写过程中产生的新操作，会把新操作也记录一份到AOF重写日志缓冲区，待重写完成后写入新的AOF文件并替换旧的AOF文件")])])]),v._v(" "),t("p",[t("img",{attrs:{src:"http://img.zhoubg.cn/static/image-20220616113324263.png",alt:"image-20220616113324263"}})]),v._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[v._v("Redis 使用记录AOF日志的方法避免数据丢失。该方法通过逐一记录写操作的命令，并在恢复时重新逐一执行命令，来保证数据的可靠性。")]),v._v(" "),t("p",[v._v("Redis 考虑到了性能的影响，提供了三种AOF日志回写方式：Always、Everysec、No，三种方式可靠性从高到低，性能从低到高。")]),v._v(" "),t("p",[v._v("Redis 为了避免AOF日志文件过大，提供了AOF重写机制。以数据库最新的状态，生成插入命令，作为新日志。重写通过后台线程完成，避免了阻塞。")])])}),[],!1,null,null,null);_.default=a.exports}}]);