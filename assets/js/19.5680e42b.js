(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{511:function(t,e,s){"use strict";s.r(e);var v=s(22),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"redis-真的是单线程吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-真的是单线程吗"}},[t._v("#")]),t._v(" Redis 真的是单线程吗？")]),t._v(" "),s("p",[t._v("我们通常说，Redis 是单线程，"),s("strong",[t._v("主要是指 Redis 的网络 IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程")]),t._v("。")]),t._v(" "),s("p",[t._v("Redis的其他功能，比如持久化、异步删除、集群数据同步等操作，是有额外的线程执行。")]),t._v(" "),s("h2",{attrs:{id:"为什么使用单线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用单线程"}},[t._v("#")]),t._v(" 为什么使用单线程？")]),t._v(" "),s("p",[t._v("先看一下多线的的开销")]),t._v(" "),s("h3",{attrs:{id:"多线程的开销"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程的开销"}},[t._v("#")]),t._v(" 多线程的开销")]),t._v(" "),s("p",[t._v("期望：使用多线程，可以增加系统吞吐率，但是前提是拥有合理资源分配和良好的系统设计")]),t._v(" "),s("p",[t._v("实际：刚开始增加线程时，吞吐率会增加，但是进一步增加线程，吞吐率增长迟缓，有事甚至下降")]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"http://img.zhoubg.cn/static/image-20220609145442851.png",alt:"image-20220609145442851"}}),t._v(" "),s("p",[s("strong",[t._v("多线程编程模式面临的共享资源的并发访问控制问题")]),t._v("，而且采用多线程一般会引入同步原语保护共享资源的并发访问，这会降低系统的易调试性和可维护性。为了避免这些问题，Redis直接采用单线程。")]),t._v(" "),s("h3",{attrs:{id:"单线程为什么快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单线程为什么快"}},[t._v("#")]),t._v(" 单线程为什么快？")]),t._v(" "),s("p",[t._v("Redis高性能的原因，一方面是全部内存操作，加上高效的数据结构。")]),t._v(" "),s("p",[t._v("另一方面就是 Redis 采用了"),s("strong",[t._v("多路复用机制")]),t._v("，要了解多路复用，先要明白网络的基本 IO 模型和潜在的阻塞点，Redis单线程如果在阻塞点上阻塞了那肯定快不了")]),t._v(" "),s("h4",{attrs:{id:"网络基本io模型与阻塞点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络基本io模型与阻塞点"}},[t._v("#")]),t._v(" 网络基本IO模型与阻塞点")]),t._v(" "),s("p",[t._v("以 Redis  的 GET 请求为例，Redis 服务端首先要监听客户端请求（bind/listen），然后建立连接（accept），从socket 中读取数据（recv），解析客户端请求数据（parse），根据请求类型读取键值对数据（get），最后给客户端返回结果，即想socket 总写会数据（send）。")]),t._v(" "),s("p",[t._v("其中，bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作。")]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"http://img.zhoubg.cn/static/image-20220609153701053.png",alt:"image-20220609153701053"}}),t._v(" "),s("p",[t._v("其中有两个潜在的阻塞点："),s("strong",[t._v("accept()")]),t._v(" 操作 和 "),s("strong",[t._v("recv()")]),t._v(" 操作。")]),t._v(" "),s("ul",[s("li",[t._v("Redis 监听到一个客户端连接，如果连接一直未能建立成功是，accept会阻塞，此时其他客户端不能与Redis连接")]),t._v(" "),s("li",[t._v("Redis 通过 recv 从一个客户端读取数据，如果数据一直没到达，Redis 也会阻塞在 recv")])]),t._v(" "),s("p",[t._v("这就导致了Redis整个线程的阻塞，无法处理其他客户端请求，效率低下。但是 socket 网络模型本身支持非阻塞模式。")]),t._v(" "),s("h4",{attrs:{id:"非阻塞模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞模式"}},[t._v("#")]),t._v(" 非阻塞模式")]),t._v(" "),s("p",[t._v("Socket 网络模型的非阻塞设置，主要体现在三个系统函数调用上：")]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"http://img.zhoubg.cn/static/image-20220609161148535.png",alt:"image-20220609161148535"}}),t._v(" "),s("ul",[s("li",[t._v("调用listen() 方法设置非阻塞模式，accept() 操作就不会阻塞，没有连接到来，Redis线程可以干其他事")]),t._v(" "),s("li",[t._v("调用accept() 方法设置非阻塞模式，send()/recv() 查找就不会阻塞，已连接套接字上数据没有到达，Redis线程可以干其他事")])]),t._v(" "),s("p",[t._v("上述两种设置非阻塞后，Redis线程可以不用等待，但总的有一种机制保证当请求来了或者数据到达能通知Redis线程去处理吧，这就是linux中 IO 多路复用机制的作用了")]),t._v(" "),s("h4",{attrs:{id:"基于多路复用的高可用io模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于多路复用的高可用io模型"}},[t._v("#")]),t._v(" 基于多路复用的高可用IO模型")]),t._v(" "),s("p",[t._v("Linux 中 IO 多路复用机制是指一个线程处理多个 IO 流，就是常说的 select/epoll 机制。")]),t._v(" "),s("p",[t._v("Redis 运行单线程情况下，"),s("strong",[t._v("该机制允许在内核中，同时监听多有监听套接字和已连接套接字")]),t._v("。监听这些套接字上连接请求和数据请求，一旦请求到达，就交个Redis线程处理。")]),t._v(" "),s("p",[t._v("下图就是Redis了IO 多路复用模型，内核调用epoll机制监听多个套接字FD，此时Redis不会阻塞在某个特定监听或已连接套接字上，也就是不会阻塞在某个特定的请求处理上，可以同时和多个客户端连接并处理请求，提升并发性。")]),t._v(" "),s("img",{staticStyle:{zoom:"67%"},attrs:{src:"http://img.zhoubg.cn/static/image-20220609162735718.png",alt:"image-20220609162735718"}}),t._v(" "),s("p",[t._v("为了请求到达时通知Redis，select/epoll 提供了"),s("strong",[t._v("基于事件的回调机制，即针对不同的事件，调用不同的处理函数")])]),t._v(" "),s("p",[t._v("如图所示，当监测的FD上一旦有请求到达，就会触发相应的事件（AcceptEvent、ReadEvent、WriteEvent），这些事件会先进入到一个事件队列中，Redis单线程会不断的对该事件队列进行处理，针对不同的事件类型调用不同的处理函数，这样就避免了Redis线程一直轮询浪费CPU资源。")]),t._v(" "),s("p",[t._v("不同的操作系统，多路不用有不同的实现，既有基于 Linux 系统下的 select 和 epoll 实现，也有基于 FreeBSD 的 kqueue 实现，以及基于 Solaris 的 evport 实现，这样，可以根据Redis 实际运行的操作系统，选择相应的多路复用实现。")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("redis真的是单线程吗？")]),t._v(" "),s("blockquote",[s("p",[t._v("Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线")])]),t._v(" "),s("p",[t._v("为什么用单线程？")]),t._v(" "),s("blockquote",[s("p",[t._v("采用单线程的一个核心原因是避免多线程开发的并发控制问题")])]),t._v(" "),s("p",[t._v("单线程为什么这么快？")]),t._v(" "),s("blockquote",[s("p",[t._v("单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点")])])])}),[],!1,null,null,null);e.default=_.exports}}]);